
\documentclass[numbers=noenddot, abstract=on]{scrreprt}

% Setting heading fonts to serif
\addtokomafont{disposition}{\rmfamily}

\usepackage[english]{babel} 
\usepackage[utf8]{inputenc}
\usepackage[backend=bibtex8]{biblatex}
\bibliography{bib/bibliography.bib}

% Using links in PDFs, but without the ugly borders
\usepackage{hyperref}
\hypersetup{
    colorlinks=false,
    pdfborder={0 0 0},
}

% we need these packages for the gantt chart
\usepackage{pgfgantt}
\usepackage{rotating}

% We need this to display the group symbols correctly
\usepackage{amssymb}
\usepackage{amsmath}


% definitions of own commands
\newcommand{\myref}[1]{(see section \ref{#1} on page \pageref{#1})}

\begin{document}

\title{\bf E-Voting on Android Devices using the CGS97 Protocol}
\subject{Master Thesis Proposal}
\author{Juerg Ritter (\url{rittj1@bfh.ch})\\
\\
Bern University of Applied Sciences\\
Engineering and Information Technology\\
CH-2501 Biel, Switzerland\\
}
\date{\today}
\publishers{Advisor:\\
Prof. Dr. Rolf Haenni, Bern University of Applied Sciences\\
\bigskip
Expert:\\
Stephan Neumann, Technical University of Darmstadt}
\maketitle



\begin{abstract}
The E-Voting group of the Bern University of Applied Sciences is planning to
evaluate decentralized E-Voting systems for practical use. The term
``decentralized'' in that context means that there is no central server
infrastructure involved in the voting process. The main application of such
E-Voting systems are polls with a low number of participants, for example the
board of directors in a company. The idea is, that the participants create an
ad-hoc network with mobile devices. The goal of this project is to implement a
decentralized E-Voting system for Android devices. The communications scheme among
the voting participants will rely on the proposal made by Ronald Cramer,
Rosario Gennaro and Berry Schoenmakers in 1997 \cite{CGS97}. The cryptographic
library UniCrypt and InstaCircle which is an ad-hoc decentralized communication infrastructure are
other foundation blocks of this project. UniCrypt and InstaCircle are both
projects which have been implemented at the Bern University of Applied Sciences.
\end{abstract}

\tableofcontents

\chapter{Introduction}
\label{cha:introduction}
One of the research fields of the Bern University of Applied Sciences is the
area of E-Voting. E-Voting has become a big field of research in the past couple
years. Still, there is no generic approach which meets all the criteria such as
privacy, transparency, etc. which we want in E-Voting. The E-Voting research
group of the Bern University of Applied Sciences \cite{www:EVG} tries to
improve this situation with the following approaches:
\begin{itemize}
  \item Develop new approaches and provide them to the community for review
  \item Take existing approaches and evaluate them in terms of practicability.
  These approaches are usually available as scientific papers
\end{itemize}

The evaluation of these approaches is usually done by implementing them into a
prototype level application to show that the approach actually works. The
E-Voting group would like to gain some experience on how decentralized E-Voting
systems could be implemented and how they behave in practice. There are some
approaches which focus explicitly on decentralized E-Voting systems, such as the
proposal of Khader et al. \cite{HKRS12}. In this project, we would like to adapt
the protocol proposed by Cramer et. al. \cite{CGS97} in a way that it can be
used as a decentralized E-Voting system.

A possible use case of such a system could be an executive board or any other
committee that would like to vote on some matters without having their members
to reveal what exactly they voted for. The architecture of our system requires
that all the participants are in a confined space and are able to exchange some
sort of credential using a non-electronic channel.

The goal of this project is to build Systems which allows perform elections and
polls on mobile Android devices under the following terms:
\begin{itemize}
  \item Voting needs to be done ad-hoc, meaning that no infrastructure other
  than the participants' mobile devices are required to perform an election or
  poll.
  \item The voting scheme is based on the CGS97 approach proposed by Cramer et
  al.~\cite{CGS97}.
  \item It must be possible to perform elections or polls with the type $1-n$,
  meaning the voter can choose exactly one option out of $n$ possible options.
  It will not be possible to perform elections where multiple candidates can be
  elected for example.
\end{itemize}

In previous projects during the master studies, some groundwork has been
implemented which can now be used as a foundation for this project. The
previously implemented projects are the following:
\begin{itemize}
  \item \textbf{UniCrypt:} Unicrypt is a cryptographic library developed by the
  members of the E-Voting Group of the Bern University of Applied Sciences. It
  provides cryptographic building blocks such as the ElGamal crypto system, Zero
  Knowledge Proofs, digital Signatures, etc. 
  \item \textbf{InstaCircle: } InstaCircle provides a decentralized
  communication platform for Android devices. It allows to exchange messages
  using Wi-Fi among a closed user group.
\end{itemize}
The projects mentioned above will be discussed in more detail in the section
``Background and related work'' \myref{cha:brw}.

The time budget of this Master Thesis is one year, although the project will be
implemented part time. It is equivalent to 27 ECTS credits. 

\chapter{Background and related work}
\label{cha:brw}
This section gives an overview of the theoretical foundations and some projects
which have been implemented earlier in order to serve as a foundation for this
project.

\section{The voting scheme CGS97}
\label{sec:CGS97}
In 1997, Ronald Cramer, Rosario Gennaro and Berry Schoenmakers proposed a scheme
\cite{CGS97} which allows to do E-Voting in a secure and verifiable manner. The participants of
the protocol can be divided into three different categories:
\begin{itemize}
  \item \textbf{Voter:} A voter is somebody who is eligible to participate on
  an election or a poll. 
  \item \textbf{Trustee:} A trustee is somebody who helps setting up the
  election by creating an asymmetric key pair in cooperation with other
  trustees.
  At the end of the election phase, the trustees have to cooperate in order to
  reveal the result of the election or the poll.
  \item \textbf{Observer:} An observer is somebody who wants to verify that all
  the participants of an election or a poll behave as they are supposed to.
\end{itemize}

In the scenario of an ad-hoc voting system as we are going to develop during
this project, the three roles can be combined, meaning that all voters are also
acting as a trustee. 

\subsection{Cryptographic Building Blocks}
\label{sec:buildingblocks}
The CGS97 voting scheme is assembled from some well known cryptographic building
blocks which are shortly explained in this section.

\subsubsection{ElGamal Cryptosystem}
\label{sec:elgamal}
The ElGamal cryptosystem \cite{EG84}, proposed by Taher El Gamal in 1984, is the
asymmetric cryptosystem which is mostly used in the context of E-Voting. An
asymmetric cryptosystem uses two keys to operate, one which is used to encrypt a
certain message (the public key) and another to decrypt the message (the secret
key). The security of this cryptosystem is based on the fact that it is hard to
compute the logarithm in discrete modular groups and hence making the
exponentiation in modular groups a one way function. A major advantage of the
ElGamal cryptosystem is the fact, that the encryption function includes a random
value. Especially in the context of E-Voting this is a crucial property, because
when encrypting a value (for example the value $1$ which means \textit{Yes}),
the resulting ciphertext is always different. That's why ElGamal is also called
a \textit{randomized} cryptosystem.

In order to define an ElGamal cryptosystem, three parameters are required. Let
$p$ and $q$ be large prime numbers such that $q|p-1$. $p$ and $q$ are so called
save primes. $q$ defines the order of a subgroup $G_q$ of the multiplicative
modular group $\mathbb{Z}^*_p$. The last parameter needed is a random generator
$g$ of the group $G_q$. We can now derive the asymmetric key pair containing the
secret key $x \in_R \mathbb{Z}_q$ and the public key $y=g^x \in G_q$. A message
$m \in G_q$ can be encrypted by first choosing a random value $r \in_R
\mathbb{Z}_q$, and then calculating $(a, b)=Enc_y(m, r)=(g^r, y^r \cdot m)$. The
tuple $(a, b)$ is the ciphertext of the message $m$. $m$ can be recovered using
the secret key $x$ by calculating $m=Dec_x(a, b)=a^{-x} \cdot b$.

\subsubsection{Subgroup Encoding}
\label{sec:subgroupencoding}
In the previous section, we have seen that the ElGamal encryption function takes
a message $m \in G_q$ and a random value $r \in_R \mathbb{Z}_q$ as a function
parameter. Since the group $G_q$ contains a non-continuous set of integer numbers
between $1$ and $p-1$, we need a mechanism to make sure that $m$ is an element
of $G_q$ We call this operation \textit{encoding}.
Assuming $g$ is a generator of the group $G_q$, we could just calculate
$m=g^{m'}$, where $m' \in \mathbb{Z}_q$. This works because $G_q = \{g^0, g^1,
g^2, \ldots, g^{q-1}\}$. While the encoding process is quite simple, the
decoding part is more difficult because in order to find $m'$, we need to
calculate the discrete logarithm which cannot be done in an efficient manner.
Thus, this encoding scheme is only applicable to a small set of possible
plaintexts.

There is also a more efficient mechanism which allows to
map values between the groups $\mathbb{Z}_q$ and $G_q$. The encoding can be done
as follows:
\begin{equation}
\text{Encode} : \mathbb{Z}_q \rightarrow G_q, \text{Encode}(m') = 
	\begin{cases}
	m'+1 & \text{if } (m'+1)^q = 1 \text{ mod } p \\
	p-m'-1 & \text{else}
	\end{cases} \notag
\end{equation}

The decoding function on the other hand looks as follows:

\begin{equation}
\text{Decode} : G_q \rightarrow \mathbb{Z}_q, \text{Decode}(m) = 
	\begin{cases}
	m-1 & \text{if } m \leq q \\
	p-m-1 & \text{else}
	\end{cases} \notag
\end{equation}

\subsubsection{Homomorphic encryption}
\label{sec:homenc}
The ElGamal cryptosystem has a property
which is important for building verifiable E-Voting schemes, namely the property
of homomorphism. Given two mathematical groups $(X,\oplus)$ and $(Y,\otimes)$, a
mathematical function $f:X \rightarrow Y$ is $(\oplus, \otimes)$-homomorphic if
the following condition holds:
\begin{equation}
f(m_1) \otimes f(m_2) = f(m_1 \oplus m_2) \notag
\end{equation}
The ElGamal function offers exactly that property with respect to the
multiplication operation for its encryption function $Enc_y:G_q \times
\mathbb{Z}_q \rightarrow G_q \times G_q$ using the same public key $y$:
\begin{equation}
Enc_y(m_1, r_1) \cdot Enc_y(m_2, r_2) = Enc_y(m_1 \cdot m_2, r_1 \cdot r_2)
\notag
\end{equation}
This property allows to calculate the encrypted product of all messages out of
the encrypted messages and decrypt only the result. Applied to E-Voting, the
result can be calculated out of the encrypted ballots and only the final result
needs to be decrypted. The ballots themselves can remain encrypted, which is
important for maintaining privacy. The ElGamal cryptosystem is homomorphic
respective to multiplication, which is not very fortunate for counting votes.
Votes should be summed up in order to get the final result. In order to reach
this, we use the following mathematical property:
\begin{equation}
x^a \cdot x^b = x^{a+b} \notag
\end{equation}

Applied to ElGamal, this transforms to the following equation:

\begin{equation}
Enc_y(g^{m_1}) \cdot Enc_y(g^{m_2}) = Enc_y(g^{m_1 + m_2}) \notag
\end{equation}

In order to obtain the sum of $m_1$ and $m_2$, the computation of a discrete
logarithm is required, which is considered as a hard problem. In the scenario of
E-Voting, we know what the possible solutions are. The number of possible
solution is merely the number of ballots which have been cast, so we can just
iterate through all the possible solutions and stop as soon as it matches with
the decrypted product.


\subsubsection{Secret sharing}
\label{sec:secretsharing}
In E-Voting scenarios it is crucial that not a
single entity can manipulate the result or reveal single votes. This
responsibility, or in our case the secret key which is needed to obtain the
final result, has to be spread across a set of trustees. In the CGS97 scheme,
this property is achieved by using a secret sharing mechanism as proposed by Adi
Shamir in 1979 \cite{Shamir79}. This scheme even allows to define a so called
\textit{threshold}, which defines the minimal amount of participating trustees
in order to decrypt the result. Such a system is also known as a
$(t-n)$-threshold scheme, where $n$ defines the number of shares which are
issued at the beginning and $t$ defines the number of participants needed to
recover the secret. In a first step, a trusted dealer defines a polynomial
function $f(x)$ with degree $t-1$ and random coefficients. Each trustee $A_{i |
1 \leq i \leq n}$ gets its share $s_i=f(i)$. Secret itself, at this stage only
known by the trusted dealer, is defined by $s=f(0)$. In order to reproduce the
secret using the shares distributed among all trustees, we can interpolate the
shares in order to reproduce the coefficients and therefore also $f(x)$. Since a
polynomial function of degree $t-1$ needs at least $t$ points to reproduce using
an interpolation technique such as Lagrange interpolation, the secret can only
be reproduced if at least $t$ trustees are collaborating. 

The approach of Shamir is quite simple, has one major drawback though: It
requires a trusted authority which has the knowledge of the shared key. It it
would be nice to have a scheme where the group of trustees collaborate to create
the shares in a way that nobody can derive the private key unless a sufficient
amount of trustees collaborate. In 1991, Torben Pryds Pedersen proposed a scheme
where this trusted dealer is no longer needed \cite{PED91}. In this scheme, all the
trustees perform the steps of the trusted dealer in the scheme of Shamir, namely
they generate a polynomial function with random coefficients of degree $t-1$ and
calculate a point for each trustee in the system. These points are then
\textit{secretly} communicated individually to each trustee.

\subsubsection{Zero-Knowledge proofs}
\label{sec:zeroknowledgeproofs}
Zero-knowledge proofs (ZKPs) in their sense are conversations between a
\textit{prover} and a \textit{verifier}. They allow the prover to demonstrate,
that she knows a secret without actually revealing the secret itself. The
conversation is similar to a challenge-response protocol, the verifier asks the
prover certain questions about the secret and the verifier answers them. This
kind of conversations are also known as $\Sigma$-protocols. Of course, the
prover could just guess the correct answer to the question and cheat, but if the
verifier repeats the challenge process with a different input, chances are
almost zero that the prover can guess all the correct answers if he is not in
fact in possession of the secret. Zero knowledge proofs offer therefore a
\textit{probabilistic} security. In the context of E-Voting, these Zero
Knowledge Proofs are used to make sure that none of the participants are
cheating.

\paragraph{Non-Interactive Zero-Knowledge proofs.}
Zero-knowledge proofs as described above are \textit{interactive} conversations
between a prover and a verifier. This also means that the prover proofs only to
the verifier that she has knowledge of the secret. Of course, any observer could
observe the conversation, but there is no way to determine whether the verifier
actually accepts the the proof or not. The verifier could of course testify that
the prover has the knowledge of the secret, but that would require a trust
relationship between the observer and the verifier. In an E-Voting scenario, we
need a proof which can be verified by anybody and doesn't require an interactive
conversation between the verifier and the prover. Such proofs are called
\textit{Non-Interactive Zero-Knowledge proofs} or \textit{NIZKPs}. The
foundation of these NIZKPs were introduced by Amos Fiat and Adi Shamir in 1986
\cite{FS87}, later known as the \textit{Fiat-Shamir heuristic}. Instead of the
verifer challenging the prover, the prover challenges himself by using a
\textit{hashfunction} such as SHA-1. The result of such a Non-interactive
Zero-Knowledge Proof is similar to a digital signature. Once published,
everybody can verify the integrity of the data over which the signature has been
calculated. In a similar way, Non-interactive Zero-Knowlege proofs can be
verified, with the important difference that the secret of course remains
secret. So far, we didn't specify what a secret actually is. There are multiple
types of secrets and therefore also multiple types of Zero-Knowledge proofs, but
due to the work of Ueli Maurer \cite{Maurer09} we can formulate a general
recipie how such a NIZKP is assembled:

Let $(X,\oplus)$ and $(Y,\otimes)$ be two mathematical groups and
$f:X \rightarrow Y$ be a one-way homomorphic function. The prover wants to prove
that she knows the preimage $a \in X$ of the publicly known value $b \in Y$,
where $b=f(a)$. In order to prove the knowledge of the value $a$, the prover
performs the following steps:
\begin{enumerate}
  \item Choose a uniformly random value $\omega \in_R X$
  \item Compute $t=f(\omega)$
  \item Compute $c=H(b,t)$, where $H$ represents a \textit{hashfunction} such as
  SHA-1
  \item Compute $s=\omega \oplus c \otimes a$
  \item Publish the proof $\pi = (t,s)$
\end{enumerate}

A verifier can now calculate $c=H(b,t)$ and check whether the following
condition holds:
\begin{equation}
	f(s) \stackrel{?}{=} t \otimes b^c \notag
\end{equation}

 In the following paragraphs, the different types of proofs are briefly
 explained and we also make the adaption of the schema above.
 
\subparagraph{Proving the Knowledge of discrete logarithm.}
This type of Proof was first presented by Claus Peter Schnorr in 1991
\cite{Schnorr91}. We have seen that the ElGamal encryption function has the
homomorphic property \myref{sec:homenc}. Therefore, it is possible to prove the
knowledge of the plaintext of a given ciphertext by applying the scheme above.
We define the ElGamal encryption function using the public key $y$ and the
predefined generator $g$ of the group $G_q$ as follows:
\begin{equation}
	Enc_y:G_q \times \mathbb{Z}_q \rightarrow G_q \times G_q, (a,b) = Enc_y(m,
	r)=(g^r, y^r \cdot m) \notag
\end{equation} 

Since $g$ and $y$ are publicly known values, the knowledge of the value $r$
implies the knowlege of $m$, therefore the prover only needs to prove the
knowlege of $r$, which can be done by substituting the following variables in
the generic scheme above:
\begin{align}
  X &= \mathbb{Z}_q \notag \\
  Y &= G_q \notag \\
  a &=m \notag \\
  b &=r \notag \\
  f(x) &= g^x \notag
\end{align} 


This translates to the following steps:

\begin{enumerate}
  \item Choose a uniformly random value $\omega \in_R \mathbb{Z}_q$
  \item Compute $t=g^\omega$
  \item Compute $c=H(a,t)$, where $H$ represents a \textit{hashfunction} such as
  SHA-1
  \item Compute $s=\omega + c \cdot r$
  \item Publish the proof $\pi = (t,s)$
\end{enumerate}

A verifier can now verify the knowledge of $r$ and therefore $m$ by calculating
$c=H(a,t)$ and check whether the following condition holds:
\begin{equation}
	g^s \stackrel{?}{=} t \cdot a^c \notag
\end{equation}

\subparagraph{Proving the Equality of Discrete Logarithms.}
This type of proof due to David Chaum and Torben Pryds Pedersen \cite{CP93}
that proofs the relation $log_{g_1} c_1 = log_{g_2} c_2 $ for two values $c_1 =
g_1^m$ and $c_2 = g_2^m$, where $g_1$ and $g_2$ are generators of the
mathematical group $G_q$. In order to prove this relation, we can again
substitute the variables in the scheme above:
\begin{align}
  X &= \mathbb{Z}_q \notag \\
  Y &= G_q \times G_q \notag \\
  a &=m \notag \\
  b &=(c_1, c_2) \notag \\
  f(x) &= (g_1^x, g_2^x) \notag
\end{align} 

This translates to the following steps:

\begin{enumerate}
  \item Choose a uniformly random value $\omega \in_R \mathbb{Z}_q$
  \item Compute $t=(g_1^\omega, g_2^\omega)$
  \item Compute $c=H((c_1,c_2),t)$, where $H$ represents a \textit{hashfunction}
  such as SHA-1
  \item Compute $s=\omega + c \cdot m$
  \item Publish the proof $\pi = (t,s)$
\end{enumerate}

A verifier can now verify the relation by calculating
$c=H((c_1,c_2),t)$ and check whether the following condition holds:
\begin{equation}
	(g_1^s, g_2^s) \stackrel{?}{=} t \cdot (c_1, c_2)^c \notag
\end{equation}


\subparagraph{Proving Validity.}
This section needs to be written.  

\subsubsection{Bulletin Board}
\label{sec:bulletinboard}
The so called bulletin board is the public communication channel which is used
to communicate between the participants of the election or poll. It is a
transcript of all the communication steps between the participants and therefore
contains encrypted ballots, zero knowledge proofs, etc. The bulletin board is
also available for observers. Using the content of the bulletin board, everybody
can verify that all the participants are following the protocol or that
dishonest participants are excluded from the voting process. A voter can verify
that his/her own ballot is counted properly and also reflects in the final
result. In theory, it is not possible to delete anything from a bulletin board
(append only). Since the bulletin board is a good target for a denial-of-service
attack, it is a good idea to replicate the content of the bulletin board to
multiple systems.

\section{UniCrypt}
\label{sec:unicrypt}
UniCrypt is the name of a cryptographic library which has been developed by the
E-Voting group of the Bern University of Applied Sciences. The main goal of this
project was to create a platform on which upcoming projects can be built on.
UniCrypt tries to look at cryptographic functions such as cryptosystems,
signature systems, hash functions etc. from a mathematical point of view. Cipher
text, plain text, signatures, etc. are treated as elements of mathematical
groups, the cryptographic functions are treated as mathematical functions. This
is required because in secure protocols as we use in the area of E-Voting, we
depend on the plain textbook implementation of the cryptographic functions
without functions like automatic padding, encoding, etc. This is the main
difference between UniCrypt and other cryptographic libraries.

At the moment, UniCrypt has only been used in classic Java environments, but not
on mobile devices. Further information about UniCrypt can be found in
\cite{ritter12}.

\section{InstaCircle}
\label{sec:instacircle}
InstaCircle is the name of a project that has been implemented as a preparation
of this master thesis. It is intended as a platform to connect mobile devices
in a confined space to a Wi-Fi ad-hoc network in order to exchange broadcast
and unicast messages. In order to keep the network traffic as low as possible,
the basic communication relies on broadcast messages. Since it is not possible
implement a reliable protocol using broadcast techniques, mechanisms to
compensate message losses have been implemented. These resending mechanisms rely
on a reliable unicast channel.

From a usability perspective, the process on agreeing to a communication channel
for an ad-hoc network is quite challenging. All the participants need to have
the know-how to switch their devices to the correct Wi-Fi network and enter the
correct keys and passwords. InstaCircle tries to improve the usability by
allowing the users to exchange the configuration by sharing a QR code or a NFC
tag. Once a user has set up a conversation, other participants can join the
conversation by reading the QR code or the NFC tag shared by the initiator of
the conversation.

InstaCircle is currently available for Android devices only. Further information
about InstaCircle can be found in \cite{ritter13a}.

\chapter{Expected Results}
\label{cha:expectedresults}
The final result of this project is a fully-fledged decentralized E-Voting
application which runs on Android devices and does not require any equipment
other than the Android smartphones or tablets. Since a considerable amount of
people carry such devices, which allows setting up spontaneous polls. The
implementation can be split up in several packages, which are shortly explained
in the following section.

\section{Threshold Secret Sharing}
\label{sec:thresholdsecretsharing}
In order to ensure privacy of the ballots, the CGS97 \cite{CGS97} E-Voting
protocol uses a threshold secret sharing mechanism which splits up the secret
key which will later be used for decrypting the result among an certain number
of trustees. Since the protocol allows participants to impersonate multiple
rules, all participants could also be trustees. In the scenario of an ad-hoc
E-Voting setup, it certainly makes sense to assign the role of the trustee to
all participants. This is because of the following reasons:
\begin{itemize}
  \item In many cases, the number of participants in an ad-hoc poll can be so
  small that it would be hard to find an even smaller subset of participants
  which will act as trustees.
  \item In classical large-scale elections or polls, the role of the trustee
  will probably be assigned to organizations such as political parties,
  governmental authorities, election observation organizations, etc. In
  spontaneous ad-hoc polls, the question of who gets to be a trustee is not an
  obvious one, so it is probably the best choice to assign this role to all
  participants.
  \item Assigning the role of a trustee to all participants other than just to a
  subset of participants means that the handling of the application would be the
  same for all the participants (except for one special participant who defines
  the question and the allowed options of the poll). That simplifies the design
  of the User interface and avoids confusion about who has to do what during the
  poll.
\end{itemize}

The CGS97 protocol suggests to use threshold secret sharing scheme due to Torben
Pryds Pedersen \cite{PED91}, which adds a distributed key generation mechanism to the
scheme proposed by Adi Shamir \cite{Shamir79}. Especially the key generation
part of the protocol involves a lot of steps and interaction between participants.

The secret sharing mechanism is currently not part of the InstaCircle library
and has to be implemented. The implementation such a threshold mechanism in
InstaCircle is a goal for this project.

\section{Graphical User Interface}
\label{sec:gui}
In many cases, cryptographic functions which are heavily used in the context of
E-Voting have a negative impact on the usability. Many steps such as key
generation, decryption, etc. have to be done in order to guarantee a poll which
can't be compromised, and these steps bring a certain complexity into the
handling of the application. Therefore it is crucial to guide the user
through the process, and this can only be done by providing them a carefully
crafted user interface. We can divide the required user interface into the
following components:
\begin{itemize}
  \item \textbf{Administration:} The very first step in a poll would be to
  define the question of the poll and the allowed options. Also, some sort of
  access credential has to be defined. This step has to be performed by one
  special participant, let's define this special participant as the
  \textit{initiator} of the poll. Functionality in order to open and close the
  voting period is also necessary in this part.
  \item \textbf{Voting:} One part of the interface has to deal with the
  functionality of casting a vote. It basically displays the question of the
  poll and provides functionality to choose one of the available options.
  \item \textbf{Bulletin board:} One building block of the CGS97 protocol
  \cite{CGS97} is the so called bulletin board where the whole transcript of
  messages between the participants is saved. All these information needs to be displayed on the
  user interface so that the participant has the possibility to verify the
  validity of the whole E-Voting process \myref{sec:bulletinboard}.
\end{itemize}

\section{E-Voting Functionality}
\label{sec:evotingfunctionality}
The main challenge of this project is the implementation of the logic of CGS97 
\cite{CGS97}, namely assemble the cryptographic building blocks to a working
application and tie it to the user interface and to InstaCircle for communicating to the other
participants. This part is heavily based on already existing components, namely
InstaCircle which provides the decentralized communication infrastructure and
UniCrypt which provides the implementation of the cryptographic building blocks
which are used in CGS97.

\chapter{Organization}
\label{cha:organization}
This project is implemented as a master thesis project as a graduation project
during the Master of Science in Engineering studies (MSE) at the Bern University
of applied Sciences. This project values 27 ECTS credits and is spread among two
semesters. The hand in of the project is planned for February 7, 2014.

During the same period, a fellow master student is working on a very similar
topic, namely the implementation of the decentralized E-Voting system proposed by
Dalia Khader et al. \cite{HKRS12}. This project will also be based on the
InstaCircle communication infrastructure \cite{ritter13a} and the UniCrypt
cryptographic library \cite{ritter12} which have been developed earlier during
the master studies. It is the plan to establish a collaboration between these
two project, mainly for the development of the graphical user interface. A
collaboration between these project also makes it easier to compare the
approaches and evaluate the advantages and disadvantages of the two approaches.

\section{Planning}
\label{sec:planning}
The gantt charts in figure \ref{fig:planningpart1} and figure
\ref{fig:planningpart2} visualize the steps which are planned on the time axis
during the project period. At the first stage, we define the project setup,
later on the cryptographic components will be put in place and will be tested on
the Android platform. At some point a detailed story board for the graphical
user interface will be created. Especially this project will be done in a strong
collaboration with the other project which deals with decentralized E-Voting
systems. At this stage, we have prepared all the components we need in order to
implement the actual E-Voting system. The part which will consume most of the
time budget will be the implementation and the testing of the actual E-Voting
logic. The last part will be dedicated to writing the project report of this
master thesis project.

\begin{sidewaysfigure}[ph]
\centering
\begin{ganttchart}
[vgrid, hgrid,
group/.style={draw=black, fill=black!50}, y unit chart=1cm]{26}
\gantttitle{Planning Master Thesis (part 1)}{26} \\
\gantttitlelist{8,...,33}{1} \\
\ganttmilestone{Kickoff}{0.5} \\
\ganttgroup{Writing of Project Proposal}{1}{4} \\
\ganttgroup{Secret Sharing scheme}{4}{8} \\
\ganttbar{Analyzing the possibilities of threshold secret sharing}{4}{6} \\
\ganttbar{Implementing secret sharing into UniCrypt}{5}{8} \\
\ganttbar{Testing the secret sharing scheme}{7}{8} \\
\ganttgroup{Evaluation of UniCrypt on Android}{9}{10} \\
\ganttbar{Testing out Example code on Android}{9}{9} \\
\ganttbar{Integration of code into Android project}{10}{10} \\
\ganttgroup{Implementation of E-Voting Application of Android}{11}{26} \\
\ganttbar{Design of storyboard}{11}{12}\\
\ganttbar{Implementation of the User Interface}{12}{15}\\
\ganttbar{Implementation of the E-Voting logic}{20}{26}\\
\ganttgroup{Testing}{30}{30} \\
\ganttgroup{Documentation / Report}{1}{8} \\
\ganttmilestone{Hand in}{30}
\end{ganttchart}
\caption{Planning part 1}
\label{fig:planningpart1}
\end{sidewaysfigure}

\begin{sidewaysfigure}[ph]
\centering
\begin{ganttchart}
[vgrid, hgrid,
group/.style={draw=black, fill=black!50}, y unit chart=1cm]{25}
\gantttitle{Planning Master Thesis (part 2)}{25} \\
\gantttitlelist{34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,1,2,3,4,5,6}{1} \\
\ganttmilestone{Kickoff}{100} \\
\ganttgroup{Writing of Project Proposal}{100}{100} \\
\ganttgroup{Secret Sharing scheme}{100}{100} \\
\ganttbar{Analyzing the possibilities of threshold secret sharing}{100}{100} \\
\ganttbar{Implementing secret sharing into UniCrypt}{100}{100} \\
\ganttbar{Testing the secret sharing scheme}{100}{100} \\
\ganttgroup{Evaluation of UniCrypt on Android}{100}{100} \\
\ganttbar{Testing out Example code on Android}{100}{100} \\
\ganttbar{Integration of code into Android project}{100}{100} \\
\ganttgroup{Implementation of E-Voting Application of Android}{1}{13} \\
\ganttbar{Design of storyboard}{100}{100}\\
\ganttbar{Implementation of the User Interface}{100}{100}\\
\ganttbar{Implementation of the E-Voting logic}{1}{13}\\
\ganttgroup{Testing}{7}{19} \\
\ganttgroup{Documentation / Report}{14}{24.5} \\
\ganttmilestone{Hand in}{24.5}
\end{ganttchart}
\caption{Planning part 2}
\label{fig:planningpart2}
\end{sidewaysfigure}

\section{Milestones}
\label{sec:milestones}
In order to track the progress of the project, we define some milestones
throughout the project period.
\begin{itemize}
  \item \textbf{Kickoff:} The project is set up and the goals of the project
  are clear.
  \item \textbf{Building blocks ready:} At this stage, all the components we
  need (e.g. UniCrypt) are prepared and tested on the Android platform.
  \item \textbf{Hand in:} The implemenation and the documentation are finished
  and the work is handed over to the advisor.
\end{itemize}

\printbibliography

\end{document}
